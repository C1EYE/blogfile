---
title: OS Persistence
tags:
  - null
category:
  - 读书笔记
index: true
info: true
date: 2021-08-11 21:49:14
---
<!-- more -->

# 第三十六章 I/O设备

> 一个程序没有任何输入（每次运行结果相同），或者没有任何输出（那运行它干嘛?）都是不合理的

## 系统架构

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815111539.png" alt="image-20210815111539170" style="zoom:50%;" />

>  自上至下越来越慢

## 标准设备

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815112221.png" alt="image-20210815112221496" style="zoom:50%;" />

一个标准设备可以分为两个部分：

- 向系统其他部件展现的硬件接口

用来让系统软件控制硬件的操作，每个设备都有自己的特定接口和对应的协议

- 内部结构

包含接口的实现，简单的设备会用几个芯片，复杂的设备会包含简单的cpu，通用内存，一些特定芯片来实现。

## 标准协议

我们将设备接口简化为三个寄存器：

- 状态寄存器 记录设备状态
- 命令寄存器 通知设备执行具体指令
- 数据寄存器 存放数据

协议可能看起来像这样：

![image-20210815113128491](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815113128.png)

1. 轮询设备（判断是否就绪）
2. 发送数据
3. 写入指令
4. 轮询设备（判断是否完成）

>  这个简单的协议在轮询时浪费了大量CPU时间，如果此时操作系统可以切换下一个就绪进程可以大大提高CPU利用率

## 利用中断减少CPU开销

- CPU向设备发出一个请求，然后让对应进程休眠
- 当设备完成了自身的操作，会产生一个硬件中断，引发CPU跳转执行操作系统预定义好的中断服务例程（ISR）或更为简单的中断处理程序。它们会唤醒等待IO的进程继续执行。

中断允许计算和I/O重叠，提高了CPU利用率：

![image-20210815164021331](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815164021.png)

采用中断：

![image-20210815164037305](/Users/c1eye/Library/Application Support/typora-user-images/image-20210815164037305.png)

> 当设备处理很快时使用轮询效果更好，切换进程开销不小，如果设备很慢时使用中断更合适
>
> 如果设备为止，可以考虑使用混合的方法（两阶段）先轮询，如果设备没有完成就采用中断。
>
> 在服务器中最好也不要使用中断

## 利用DMA进行更高效的数据传送

> 如果让CPU来负责将内存中的数据复制到磁盘上，会浪费时间和算力

![image-20210815165651263](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815165651.png)

- c表示拷贝操作，拷贝完成后CPU才可以处理其他请求

解决这个问题的方案是DMA：

- DMA（Direct Memory Access）
- DMA引擎是系统中的一个特殊设备，可以协调完成内存和设备间的数据传递，不需要CPU介入

![image-20210815171639275](/Users/c1eye/Library/Application Support/typora-user-images/image-20210815171639275.png)

1. 首先操作系统告知DMA数据在内存中的位置，要拷贝的大小以及要拷贝到哪个设备，然后操作系统就可以处理其他请求了。

2. DMA完成任务后会抛出一个中断告知操作系统

## 设备交互的方法

- 使用明确的I/O指令

这种方式相对老一些，这些指令明确规定操作系统将数据发送到特定设备寄存器的方法。

例如x86上的in，out

这些指令通常都是「特权指令」操作系统是唯一可以与设备交互的实体。

- 内存映射

将设备寄存器作为内存地址提供，当需要访问时，操作系统装载或存入到该地址，然后硬件读取或写入到设备上。

> 二者没有明显的优势之分，当今都在使用

## 设备驱动程序

> 如何将每个设备具体的接口抽象为一个通用的操作系统的一部分？

在最底层，操作系统的一部分直到设备如何工作，将这部分软件称为「设备驱动程序」，所有交互细节封装其中。

不足之处在于，通用会让一些有特殊功能的设备无法使用这部分功能。

# 第三十七章 磁盘驱动器

> 持久数据存储的主要形式

## 接口

- 驱动器有大量扇区（512字节快）组成，每个扇区都可以读取或者写入。
- 扇区从0开始编号，因此我们可以将磁盘视为一组扇区，编号就是地址空间

- 对于块的写入是原子的

一些不成文的认识：

- 访问彼此靠近的块比访问相隔远的块快
- 访问连续的块最快

## 基本几何形状

![1](http://c.biancheng.net/cpp/uploads/allimg/140702/1-140F2020643419.jpg)

- 盘片

圆形的坚硬的片状物，通过引入磁性变化永久存储数据。磁盘可能有多个盘片，每个盘面两面都可以存储数据。

即使断电也能持久存储数据位。

- 主轴

所有盘片连接在主轴上，主轴连接电机，以恒定的转速来旋转盘片（通电时）。转速以每分钟转数来测量，典型的数值在7200~15000RPM范围。

- 磁道（track）

数据在扇区的每个同心圆上编码，称之为磁道。一个扇面包含数以千计磁道，数百个磁道只有头发宽。

- 磁头

读写由磁头完成，每个扇面都有一个磁头，磁头连接到磁盘臂上，磁盘臂控制磁头在扇面上的各个磁道移动。

## 简单的磁盘驱动器

先假设我们有这么个磁盘：

- 12个扇区（每个512字节大小）
- 逆时针旋转

![image-20210815220325166](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815220325.png)

### 单磁道延迟：旋转延迟

如果我们想读写某个块必须等待它旋转到磁头下，这就是**旋转延迟**。

如果完整的旋转延迟是R，平均就是R/2，最坏就是旋转方向相反的最近块，几乎完整转完一圈。

### 多磁道：寻道时间

![image-20210815221301436](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815221301.png)

可以看到在有多个磁道的情况下，又多了找到磁道的时间，代价高昂：

1. 得到请求
2. 磁盘臂移动到正确的磁道（这包括加速和减速两个阶段，最后还有停放时间以便确定正确的磁道）
3. 等待旋转延迟
4. 读写数据

### 一些其他细节

- 磁盘偏斜

![](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815222302.png)

磁盘偏斜（disl skew）是指每个磁道开始位置会依次向后一点，这样在磁道切换时可以避免刚好错过的情况。

- 外圈磁道比内圈有更多的扇区

连续的磁道被分为多个区域，每个区域拥有相同的扇区数量

- 磁道缓冲区

就是缓存，通常为8M或16M，读取扇区时可以将数据写入缓存，加快后序响应。

- 后写和至写

将数据放入缓存后回报完成还是写入磁盘之后回报完成？前者称为后写，这会让磁盘驱动器看起来更快，但是可能导致问题。

------

- 量纲分析得出传输512KB时间

![image-20210815230318342](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815230318.png)

## I/O时间

现在可以将I/O时间表示为三个主要部分之和：

![image-20210815230808716](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815230811.png)

比较驱动器用I/O速率更容易：

![image-20210815230931710](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815230931.png)

现在介绍两种常见的工作负载

- 随机工作负载

小（比如4KB），而且随机，常见于DBMS。

- 顺序工作负载

读取连续的大量扇区，不会跳过。

------

![image-20210815232133858](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815232133.png)

两种磁盘，一个是性能高，一个是容量大，具体计算就不算了。

下面是平均寻道时间计算：

![image-20210815232226920](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815232230.png)

## 磁盘调度

> 操作系统的磁盘调度程序将决定调度顺序，在磁盘调度中我们可以估算出每个请求所需的时间。而调度程序会尝试遵循最短任务优先（SJF）原则。

### SSTF:最短寻道时间优先

将请求按磁道远近排列，最近的优先。

![image-20210815233446571](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210815233453.png)

- 对于块可以用最近块优先NBF来解决

- 饥饿（纯粹的SSTF将忽略其他磁道的请求）

### 电梯（SCAN、C-SCAN）

按某种顺序来回扫描磁道（比如从外到内再从内到外），如果请求的块包含在扫描的磁道中，下次处理就得等到再次扫描回来的时候。

- 解决了饥饿
- 没有考虑旋转

### SPTF： 最短定位时间优先（SATF）

就是看旋转和寻道哪个更短走哪个

实现比较复杂，一般直接在驱动器内部进行。

> 有时攒一波任务再处理可能性能更好，更多细节看更多论文和书

# 第三十八章 廉价冗余磁盘阵列（RAID）

> 更大，更快，更可靠！

RAID是由多个磁盘，内存（包含易失性和非易失性），一个或多个处理器管理的系统。

- 并行使用多个磁盘可以大大提高性能
- 冗余，可以允许部分磁盘丢失

当接收一个I/O请求时，RAID会在两个不同的磁盘上写入一个相同的块，也就是保存两份。

- 完全透明，也就是直接可以替换不需要改变上层的软件和系统

## 评价RAID的指标

> 评价RAID从三个方面：容量，可靠性，性能

- 单请求延迟

单个IO请求对RAID的延迟

- RAID稳定吞吐量

并发请求的总带宽

> 我们提出一些典型的工作负载

- 顺序

对于阵列的请求是连续的

- 随机

字面那意思

## RAID0级：条带化(striping)

> 以轮转的方式将磁盘阵列的块分布在磁盘上。

![image-20210816222910470](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210816222910.png)

- 同行的大块称为条带

![image-20210816223302638](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210816223302.png)

如果每个块4KB，那这个条带就是32KB。

- 计算RAID映射

![image-20210816223700388](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210816223700.png)

> 对于块大小不为1的，需要在磁盘数上乘块的数量

**关于大块大小**

大块的大小影响并行性和定位时间，更大的块需要更少的定位时间但是降低并行性，反之亦然。

### 评价

- 容量完全利用
- 可靠性最糟，任何故障都会导致数据丢失
- 性能良好

## RAID1级：镜像

> 在系统中为每个块准备多个副本（在不同磁盘）

![image-20210816230318550](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210816230318.png)

读取时可以读取任意副本，写入时必须要更新两个副本数据。

### 分析

-  只能获得一般的容量
- 可以容许一个磁盘故障
- 写入是并行的，所以取决于最慢的那个，比单个写入要慢一些

> 写入副本可能出现更新不一致的问题，解决方案是使用某种预写日志



## RAID4级：通过奇偶校验节省空间

![image-20210817230731619](https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210817230732.png)

