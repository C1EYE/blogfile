---
title: 以fib函数介绍几种递归的套路
date: 2021-07-05 10:23:19
tags:
category:
---

# 递归

### 递归的基本思想

拆解问题

- 把规模大的问题变成规模较小的同类型问题 
- 规模较小的问题又不断变成规模更小的问题 
- 规模小到一定程度可以直接得出它的解

求解 

- 由最小规模问题的解得出较大规模问题的解
- 由较大规模问题的解不断得出规模更大问题的解 
- 最后得出原来问题的解

> 凡是可以利用上述思想解决问题的，都可以尝试使用递归 很多链表、二叉树相关的问题都可以使用递归来解决 因为链表、二叉树本身就是递归的结构（链表中包含链表，二叉树中包含二叉树）





# 回溯

> 回溯可以理解为：通过选择不同的岔路口来通往目的地（找到想要的结果） 

- 每一步都选择一条路出发，能进则进，不能进则退回上一步（回溯），换一条路再试 

- 树、图的深度优先搜索（DFS）、八皇后、走迷宫都是典型的回溯应用

## 八皇后

**八皇后问题是一个古老而著名的问题** 

在8x8格的国际象棋上摆放八个皇后，使其不能互相攻击：任意两个皇后都不能处于同一行、同一列、同一斜线上 。

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210706113349.png" alt="image-20210706113349863" style="zoom: 33%;" />

请问有多少种摆法？

- 为了方便思考，首先缩小问题规模，如下是四皇后的回溯过程

```java
public class Main {
    //索引是皇后的行号,值是皇后所在的列号
    private int[] cols;
    private int ways = 0;

    public static void main(String[] args) {
        new Main().placeQueens(4);
    }

    void placeQueens(int n) {
        if (n < 1) { return; }
        cols = new int[n];
        place(0);
        System.out.println(n + "皇后共有" + ways + "种摆法");
    }

    /**
     * 从row行开始摆放
     *
     * @param row
     */
    void place(int row) {
      //摆完所有皇后记录一次
        if (row == cols.length) {
            ways++;
            show();
            return;
        }
        for (int col = 0; col < cols.length; col++) {
            if (isValid(row, col)) {
                //在当前位置摆放皇后
                cols[row] = col;
                place(row + 1);
            }
        }

    }

    boolean isValid(int row, int col) {
        for (int i = 0; i < row; i++) {
            //当前列
            if (cols[i] == col) {
                System.out.println("["+row+"]["+col+"]=false");
                return false;
            }
            //斜线上 用斜率算
            if (row - i == Math.abs(col - cols[i])) {
                System.out.println("["+row+"]["+col+"]=false");
                return false; }
        }
        System.out.println("["+row+"]["+col+"]=true");
        return true;
    }

    void show() {
        System.out.println("第" + ways + "种摆法");
        for (int row = 0; row < cols.length; row++) {
            for (int col = 0; col < cols.length; col++) {
                if (cols[row] == col) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
        System.out.println("----------------------");
    }


}

```

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210706114444.png" alt="image-20210706114444092" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210706114531.png" alt="image-20210706114531417" style="zoom:50%;" />

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210706114542.png" alt="image-20210706114542605" style="zoom:50%;" />

- 优化判断的版本

```java
public class NQ {
    //标记该列有无皇后
    boolean[] cols;
    // \斜线上有无皇后，每个方向有2n-1个斜线
    boolean[] leftTop;
    // /斜线上有无皇后
    boolean[] rightTop;
    int[] queens;
    private int ways = 0;

    public static void main(String[] args) {
        new NQ().placeQueens(8);
    }

    void placeQueens(int n) {
        if (n < 1) { return; }
        queens = new int[n];
        cols = new boolean[n];
        leftTop = new boolean[(n << 1) - 1];
        rightTop = new boolean[leftTop.length];
        place(0);
        System.out.println(n + "皇后共有" + ways + "种摆法");
    }

    /**
     * 从row行开始摆放
     *
     * @param row
     */
    void place(int row) {
        if (row == cols.length) {
            ways++;
            show();
            return;
        }
        for (int col = 0; col < cols.length; col++) {
            if (cols[col]) { continue; }
            int ltIndex = row - col + cols.length-1;
            if (leftTop[ltIndex]) { continue; }
            int rtIndex = row + col;
            if (rightTop[rtIndex]) { continue; }

            //在当前位置摆放皇后
            cols[col] = true;
            leftTop[ltIndex] = true;
            rightTop[rtIndex] = true;
            queens[row] = col;
            place(row + 1);
          //回溯时需要将对应的位置恢复
            cols[col] = false;
            leftTop[ltIndex] = false;
            rightTop[rtIndex] = false;
        }


    }

    void show() {
        System.out.println("第" + ways + "种摆法");
        for (int row = 0; row < queens.length; row++) {
            for (int col = 0; col < queens.length; col++) {
                if (queens[row]==col) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
        System.out.println("----------------------");
    }

}


```

- 还可以使用位运算来优化掉布尔数组

> 一个字节的每一位0，1代表能不能放新的皇后

```java
public class Q8 {
    //标记该列有无皇后
    byte cols;
    // \
    short leftTop;
    // /
    short rightTop;
    int[] queens;
    private int ways = 0;

    public static void main(String[] args) {
        new NQ().placeQueens(8);
    }

    void placeQueens(int n) {
        if (n < 1) { return; }
        queens = new int[n];
        cols = 0;
        leftTop  = 0;
        rightTop = 0;
        place(0);
        System.out.println(n + "皇后共有" + ways + "种摆法");
    }

    /**
     * 从row行开始摆放
     *
     * @param row
     */
    void place(int row) {
        if (row == 8) {
            ways++;
            show();
            return;
        }
        for (int col = 0; col < 8; col++) {
            if ((cols & (1 << col)) != 0) { continue; }
            int ltIndex = row - col + 7;
            if ((leftTop & (1 << ltIndex)) == 1) { continue; }
            int rtIndex = row + col;
            if ((rightTop & (1 >> rtIndex)) == 1) { continue; }

            //在当前位置摆放皇后
            cols |= (1 << col);
            leftTop |= (1 << ltIndex);
            rightTop |= (1 << rtIndex);
            queens[row] = col;
            place(row + 1);
            cols &= ~(1 << col);
            leftTop &= ~(1 << ltIndex);
            rightTop &= ~(1 << rtIndex);
        }
    }

    void show() {
        System.out.println("第" + ways + "种摆法");
        for (int row = 0; row < queens.length; row++) {
            for (int col = 0; col < queens.length; col++) {
                if (queens[row] == col) {
                    System.out.print("1 ");
                } else {
                    System.out.print("0 ");
                }
            }
            System.out.println();
        }
        System.out.println("----------------------");
    }

}


```

# 贪心

**贪心策略，也称为贪婪策略** 

- 每一步都采取当前状态下最优的选择（局部最优解），从而希望推导出全局最优解

**贪心的应用** 

- 哈夫曼树 
- 最小生成树算法：Prim、Kruskal 
- 最短路径算法：Dijkstra

## 最优装载

在北美洲东南部，有一片神秘的海域，是海盗最活跃的加勒比海 有一天，海盗们截获了一艘装满各种各样古董的货船，每一件古董都价值连城，一旦打碎就失去了它的价值 海盗船的载重量为 W，每件古董的重量为 𝑤 i ，海盗们该如何把尽可能多数量的古董装上海盗船？ 

> 比如 W 为 30， 𝑤 i 分别为 3、5、4、10、7、14、2、11

贪心策略：每一次都优先选择重量最小的古董

① 选择重量为 2 的古董，剩重量 28 

② 选择重量为 3 的古董，剩重量 25 

③ 选择重量为 4 的古董，剩重量 21

④ 选择重量为 5 的古董，剩重量 16

⑤ 选择重量为 7 的古董，剩重量 9 

- 最多能装载 5 个古董

```java
public class Pirate {
    public static void main(String[] args) {
        int[] weights = {3, 5, 4, 10, 7, 14, 2, 11};
        int capacity = 30, weight = 0, count = 0;
        Arrays.sort(weights);
        for (int i = 0; i < weights.length&&weight<capacity; i++) {
            int newWeight = weight + weights[i];
            if (newWeight <= capacity) {
                weight = newWeight;
                count++;
            }
        }
        System.out.println("一共选了" + count + "件古董");
    }
}

```



## 零钱兑换

假设有 25 分、10 分、5 分、1 分的硬币，现要找给客户 41 分的零钱，如何办到硬币个数最少？

◼ 贪心策略：每一次都优先选择面值最大的硬币 

① 选择 25 分的硬币，剩 16 分 

② 选择 10 分的硬币，剩 6 分 

③ 选择 5 分的硬币，剩 1 分 

④ 选择 1 分的硬币，剩 0 分

- 最终的解是共 4 枚硬币 ✓ 25 分、10 分、5 分、1 分硬币各一枚

```java
public class CoinChange {
    public static void main(String[] args) {
        int[] faces = {25, 10, 5, 1};
        Arrays.sort(faces);
        int money = 41, coins = 0;
        Map<Integer, Integer> count = new TreeMap<Integer,Integer>();
        for (int i = faces.length - 1; i >= 0; i--) {
            while (money >= faces[i]) {
                money -= faces[i];
                coins++;
                count.put(faces[i], count.getOrDefault(faces[i], 0) + 1);
            }
        }
        System.out.println("共兑换了" + coins + "枚");
        for (Map.Entry<Integer, Integer> e : count.entrySet()) {
            Integer key = e.getKey();
            Integer value = e.getValue();
            System.out.println(key+":"+value);
        }
    }
}

```

> 需要注意的是贪心策略是尽可能接近最优解，但并不是一定是最优解
>
> 比如讲硬币面值换成21，29，5，1贪心策略就求不出最优解

- 贪心策略并不一定能得到全局最优解 
- 因为一般没有测试所有可能的解，容易过早做决定，所以没法达到最佳解 贪图眼前局部的利益最大化，看不到长远未来，走一步看一步

优点：简单、高效、不需要穷举所有可能，通常作为其他算法的辅助算法来使用

缺点：不从整体上考虑其他可能，每次采取局部最优解，不会再回溯，因此很少情况会得到最优解

## 0-1背包

有 n 件物品和一个最大承重为 W 的背包，每件物品的重量是 𝑤 i 、价值是 𝑣i  在保证总重量不超过 W 的前提下，将哪几件物品装入背包，可以使得背包的总价值最大？ 

**注意：每个物品只有 1 件，也就是每个物品只能选择 0 件或者 1 件，因此称为 0-1背包问题**

如果采取贪心策略，有3个方案 

① 价值主导：优先选择价值最高的物品放进背包 

② 重量主导：优先选择重量最轻的物品放进背包 

③ 价值密度主导：优先选择价值密度最高的物品放进背包（价值密度 = 价值 ÷ 重量）

> 实际上背包问题要求最优解应该使用动态规划，这里演示贪心解法

- 物品类

```java
public class Article {
    public int weight;
    public int value;
    public double valueDensity;

    public Article(int weight, int value) {
        this.weight = weight;
        this.value = value;
        valueDensity = value * 1.0 / weight;
    }
}
```

- 分为三种贪心策略

```java
public class Knapsack {
	public static void main(String[] args) {
		select("价值主导", (Article a1, Article a2) -> {
			return a2.value - a1.value;
		});
		select("重量主导", (Article a1, Article a2) -> {
			return a1.weight - a2.weight;
		});
		select("价值密度主导", (Article a1, Article a2) -> {
			return Double.compare(a2.valueDensity, a1.valueDensity);
		});
	}
	
	static void select(String title, Comparator<Article> cmp) {
		Article[] articles = new Article[] {
			new Article(35, 10), new Article(30, 40),
			new Article(60, 30), new Article(50, 50),
			new Article(40, 35), new Article(10, 40),
			new Article(25, 30)
		};
		Arrays.sort(articles, cmp);
		
		int capacity = 150, weight = 0, value = 0;
		List<Article> selectedArticles = new LinkedList<>();
		for (int i = 0; i < articles.length && weight < capacity; i++) {
			int newWeight = weight + articles[i].weight;
			if (newWeight <= capacity) {
				weight = newWeight;
				value += articles[i].value;
				selectedArticles.add(articles[i]);
			}
		}
		
		System.out.println("【" + title + "】");
		System.out.println("总价值：" + value);
		for (int i = 0; i < selectedArticles.size(); i++) {
			System.out.println(selectedArticles.get(i));
		}
		System.out.println("-----------------------------");
	}
}

```

# 分治

**分治，也就是分而治之。它的一般步骤是** 

① 将原问题分解成若干个规模较小的子问题（子问题和原问题的结构一样，只是规模不一样） 

② 子问题又不断分解成规模更小的子问题，直到不能再分解（直到可以轻易计算出子问题的解） 

③ 利用子问题的解推导出原问题的解 

- 因此，分治策略非常适合用递归 原问题 

- 需要注意的是：子问题之间是相互独立的

分治的应用 

- 快速排序 
- 归并排序 
- Karatsuba算法（大数乘法）

## 主定理

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210707113959.png" alt="image-20210707113959816" style="zoom:50%;" />

 

## 最大连续子序列和

给定一个长度为 n 的整数序列，求它的最大连续子序列和 

> 比如 –2、1、–3、4、–1、2、1、–5、4 的最大连续子序列和是 4 + (–1) + 2 + 1 = 6

- 这道题也属于最大切片问题（最大区段，Greatest Slice）

概念区分 

- 子串、子数组、子区间必须是连续的，子序列是可以不连续的

直接上暴力解法

```java
 static int maxSubarray(int[] nums) {
        if (nums == null || nums.length == 0) { return 0; }
        int max = Integer.MIN_VALUE;
        for(int begin=0;begin<nums.length;begin++){
            int sum = 0;
            for (int end = begin; end < nums.length; end++) {
                sum += nums[end];
                max = Math.max(max, sum);
            }
        }
        return max;
    }
```

分治

<img src="https://raw.githubusercontent.com/C1EYE/figureBed/main/img/20210707152817.png" alt="image-20210707152817445" style="zoom:50%;" />

```java
static int maxSubarray2(int[] nums) {
        if (nums == null || nums.length == 0) { return 0; }
        return maxSubArray2(nums, 0, nums.length);
    }

    static int maxSubArray2(int[] nums, int begin, int end) {
        if (end - begin < 2) { return nums[begin]; }
        int mid = (begin + end) >> 1;
        int leftMax = Integer.MIN_VALUE;
        int leftSum = 0;
        for (int i = mid - 1; i >= begin; i--) {
            leftSum += nums[i];
            leftMax = Math.max(leftMax, leftSum);
        }

        int rightMax = Integer.MIN_VALUE;
        int rightSum = 0;
        for (int i = mid; i < end; i++) {
            rightSum += nums[i];
            rightMax = Math.max(rightMax, rightSum);
        }
      //上面是求最长子序列被分开的情况
        return Math.max(leftMax + rightMax,
                Math.max(maxSubArray2(nums, begin, mid),
                        maxSubArray2(nums, mid, end)
                        )
                       );

    }
```

